#+TITLE: notes_Game of Life
* Rules

+ Any live cell with fewer than two live neighbours dies, as if by underpopulation.
+ Any live cell with two or three live neighbours lives on to the next generation.
+ Any live cell with more than three live neighbours dies, as if by overpopulation.
+ Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction

* Pseudocode
** Start ...

1) user inputs ~n~
   1) ~n~ is the size of the grid -> ~n x n~
2) coordinate_val = "x0y0"
3) initialize a hashmap:

   | Key  | Value |
   |------+-------|
   | x0y0 | ' '   |

4) draw_grid()
5) draw_from_hash()

** update_coordinate(coordinate_val, n) -> ()

1) extract_coordinates()
2) we have ~x index~ and ~y index~
3) if x >= n - 1
   1) set x to 0
   2) set y = ++y
4) else
   1) x = ++x
5) pass int x and int y as args to new_cordinate()
6) coordinate_val = new_cordinate()
7) push ~coordinate_val~ to hashmap:

   | Key  | Value |
   |------+-------|
   | x0y0 | ' '   |
   | x1y0 | ' '   |

** draw_grid(coordinate_val, n) -> ()

1) counter = 0
2) loop till counter == n*n
   1) if extract_coordinate().x == n - 1
      1) move to next line
   2) println" " +~n~ number of times+
   3) update_coordinate()
3) return

** extract_coordinated(coordinate_val) -> int, int

1) take "x0y0"
2) find ~x~ char within string and get index
3) find ~y~ char within string and get index
4) extract value between ~x index~ and ~y index~
5) extract value between ~y index~ and ~final index~
6) return ~x index~ and ~y index~ as int

** new_cordinate() -> &str

1) return ~char x~ + int x.to_string() + ~char y~ + int y.to_string()

** draw_from_hash()

1) iterate through hashmap -> +arcane method of iteration+ -> iterate using coordinate of y
2) get x coordinate
3) print till x coordinate hits n - 1
4) create new line
5) go to step 3
6) stop where key is x(n-1)y(n-1)

* Things to note
** get_input() and check_input()

#+begin_src rust :exports both :noeval
// use std::collections::HashMap;  // to use hashmap
// // use std::io;                    // to take user input
use std::io;                    // to take user input

fn main() {
//let mut grid_size = get_input().trim().parse::<i64>().unwrap();
//println!("{}", grid_size + 2 );

    // let ret_tup = check_input();

    loop {

        let ret_tup = check_input();

        if ret_tup.0 == true {
            println!("From main ---> {:?}, {:?}", ret_tup.0, ret_tup.1);
            break;
        }

    }
 }

fn get_input() -> String {
// fn get_input() -> &'static str{
    println!("Please enter the grid size" );

    let mut input_string = String::new();
    std::io::stdin().read_line(&mut input_string).expect("Failed");
    return input_string;

    // let my_own_str: String = input_string.to_owned();
    // let sliced_str: &str = &my_own_str[..];

    // println!("sliced_str ---> {}\nmy_own_string ---> {}", sliced_str, my_own_str);

    // return sliced_str;

    // let my_test_str: &str = "2";
    // return my_test_str;
}

// fn check_input() -> (bool, &'static str) {
fn check_input() -> (bool, String) {
    // match get_input().bytes().all(|c| c.is_ascii_digit()) {

    // let  test = get_input().bytes().all(|c| c.is_ascii_digit());
    // let test = get_input().chars().all(char::is_numeric);

    let test_var = get_input(); // i get a String

    let my_own_str: String = test_var.to_owned(); // i own the Strin
    let sliced_str: &str = &my_own_str[..];       // i cut Strin into str
    let sliced_str_new: &str = "123312";       // i cut Strin into str
    // let sliced_str: &str = test_var.as_str();       // i cut Strin into str
    // let sliced_str: &str = "123";       // if i put a str "123" then true

    println!("sliced_str ---> {}", sliced_str); // print to check input val
    println!("my_own_string ---> {}", my_own_str); // print to check input val
    // let test = sliced_str.trim().chars().all(char::is_numeric); // check if my str is a numeric


    // NOTE: FIXED - when user puts input Rust takes the input and a linebreak ("123\n")
    // We just need to remove the linebreak and everything will work
    // This way the slice is also not needed, and STAY AWAY FROM SLICING STRINGS
    // Strings in Rust are UTF-8 encoded and slicing may mess it up
    let test = test_var.trim().chars().all(char::is_numeric); // check if my str is a numeric

    println!("---------------------------------------");
    println!("Type of my_own_str");
    find_type(&my_own_str);
    println!("---------------------------------------");
    println!("Type of sliced_str");
    find_type(&sliced_str);
    println!("---------------------------------------");
    println!("Type of sliced_str_new");
    find_type(&sliced_str_new);
    println!("---------------------------------------");

    println!("TEST ---> {}", test); // print bool

    match test {
        true => return (true, test_var.trim().to_string()),
        false => return (false, "Please enter a proper number!".trim().to_string()),
    }
}

fn find_type<T>(_: &T) {
    println!("{}", std::any::type_name::<T>())
}
#+end_src
